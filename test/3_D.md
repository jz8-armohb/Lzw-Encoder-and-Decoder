# 单片机原理

$机器周期=12\times \frac 1 {f_{\rm osc}}$

## 指令系统

### 常用符号

| 符号      | 意义                                             |
| --------- | ------------------------------------------------ |
| `Rn`      | 工作寄存器中的8个寄存器`R0`～`R7`                |
| `Ri`      | 可用作**间接寻址**的寄存器，**只能是`R0`或`R1`** |
| `direct`  | 8位片内RAM或SFR（特殊功能寄存器）的直接地址      |
| `#data`   | 8位立即数（常量）                                |
| `#data16` | 16位立即数                                       |
| `addr16`  | 16位目的地址                                     |
| `addr11`  | 11位目的地址                                     |
| `rel`     | 补码形式的8位地址偏移量（范围为-128～127）       |
| `DPTR`    | 数据指针                                         |
| `bit`     | 片内RAM或SFR的位地址                             |
| `A`       | 累加器                                           |
| `ACC`     | 直接寻址方式的累加器                             |
| `B`       | 寄存器B                                          |
| `C`       | **位累加器**/进位标志位                          |
| `@`       | **间接寻址寄存器前缀符号**                       |
| `/`       | 位操作指令中，加在位地址前面，表示对该位按位求反 |
| `(x)`     | 相应地址对应单元中的内容                         |
| `((x))`   | 以`x`间接寻址的单元中的内容                      |
| `←`       | 箭头右边的内容送入箭头左边的单元内               |
| `;`       | 注释                                             |

### 指令格式

- `[标号:]操作码 [操作数1],[操作数2] [;注释]`
- 换行表示一条指令结束

### 寻址方式

| 寻址方式       | 举例                                                         | 备注                                             |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| 寄存器寻址     | `MOV A,R0 ;A←R0`（将`R0`的内容赋给`A`）                      |                                                  |
| 直接寻址       | `MOV A,3AH`（将`3AH`单元中的内容送给`A`）                    |                                                  |
| 寄存器间接寻址 | `MOV A,@R0 ;A←(R0)`（设`R0`中内容为`3AH`，`3AH`单元中的内容为`76H`，则结果为把`76H`送给`A`） | 只有`R0`或`R1`可作间接寄存器                     |
| 立即寻址       | `MOV A,#3AH`（直接将`3AH`送给`A`）                           |                                                  |
| 变址寻址       | `MOVC A,@A+DPTR ;A←(A+DPTR)`（将`A`和`DPTR`中的内容相加，并将结果对应单元中的内容送给`A`） | “`@`”针对`A+DPTR`整体                            |
| 位寻址         | `MOV C,3AH（将3AH位中的内容送给C）`                          | 位寻址区字节地址为`20H～2FH`，位地址为`00H～7FH` |
| 相对寻址       | 将`PC`的当前内容与`rel`相加，结果为跳转指令的转移地址（转移目的地址）：目的地址=转移指令地址+转移指令字节数+`rel` |                                                  |

### 字节操作指令

1. #### 数据传送

   |                                    | 功能                                       | 格式                                                         | 备注                                                         |
   | ---------------------------------- | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | `MOV`                              | 片内RAM（内部数据存储器）数据传送          | `MOV <目的操作数>,<源操作数>`                                | 目的操作数和源操作数允许的形式：<br />`@Ri`↔︎`direct`<br />`@Ri`↔︎`A`<br />`direct`↔︎`direct`<br />`direct`↔︎`Rn`<br />`direct`↔︎`A`<br />`Rn`↔︎`A`<br />`#data`→`@Ri`<br />`#data`→`direct`<br />`#data`→`Rn`<br />`#data`→`A`<br />`#data16`→`DPTR`<br />⚠️没有`Rn`→`Rn` |
   | `MOVX` (**Mov**e E**x**ternal RAM) | 片外RAM（外部数据存储器）数据传送          | 读：`MOVX A,@Ri`或`MOVX A,@DPTR`； <br>写：`MOVX @Ri,A`或`MOVX @DPTR,A` | 只能在`A`和`@Ri`/`@DPTR`间传送                               |
   | `MOVC` (**Mov**e **C**ode)         | ROM（内部/外部程序存储器）数据传送（查表） | `MOVC A,@A+PC`或`MOVC A,@A+DPTR`                             | 只能读                                                       |

2. #### 数据交换

   - 对标志位的影响：不影响`PSW`的其它标志位，只对它的奇偶校验位(`P`)有影响

   |                                           | 功能                                      | 格式                     |
   | ----------------------------------------- | ----------------------------------------- | ------------------------ |
   | `XCH` (**Exc**hange)                      | 片内RAM单元与累加器`A`进行8位数据交换     | `XCH A,30H`              |
   | `XCHD` (**Exc**hange Low-order **D**igit) | 累加器`A`的低4位与间址`Ri`单元的低4位交换 | `XCHD A,@Ri`             |
   | `SWAP`                                    | 累加器`A`高、低半字节交换                 | `SWAP A ;A=30H变为A=03H` |

3. #### 堆栈操作

   |      | 格式          | 效果                        |
   | ---- | ------------- | --------------------------- |
   | 入栈 | `PUSH direct` | `SP = SP+1, (direct)→(SP)`  |
   | 出栈 | `POP direct`  | `(SP)→(direct), SP = SP-1 ` |

   - 注意：先入栈的内容后出栈

4. #### 算术运算

   - 主要是对8位无符号数进行算术运算
   - 单字节运算
   - 对标志位的影响：除了部分`INC`、`DEC`指令外，其它的运算类指令的目的操作数必定是累加器`A`，会影响`PSW`的标志位状态

   |                                                    | 格式              | 说明                                                         |
   | :------------------------------------------------- | ----------------- | :----------------------------------------------------------- |
   | `ADD`（加法）                                      | `ADD A,<操作数>`  | `<操作数>`可为`#data`、`direct`、`@Ri`、`Rn`                 |
   | `ADDC`（带进位加法，**Add** with **C**arry）       | `ADDC A,<操作数>` | `<操作数>`可为`#data`、`direct`、`@Ri`、`Rn`<br />若和超出-128～127，则溢出标志位`OV`为1，否则为0 |
   | `SUBB`（带借位减法，**Sub**tract with **B**orrow） | `SUBB A,<操作数>` | `<操作数>`可为`#data`、`direct`、`@Ri`、`Rn`；<br />`A`为被减数；<br />借位信息存放在`CY`中 |
   | `INC`（加1，**Inc**rement）                        | `INC <操作数>`    | `<操作数>`可为`A`、`direct`、`@Ri`、`Rn`、`DPTR`             |
   | `DEC`（减1，**Dec**rement）                        | `DEC <操作数>`    | `<操作数>`可为`A`、`direct`、`@Ri`、`Rn`（`DPTR`没有减1操作） |
   | `MUL`（乘法）                                      | `MUL AB`          | `A`×`B`→`B` `A`；<br />`CY`总是被清零；<br />若乘积大于0FFH（255），则溢出标志位`OV`为1，否则为0 |
   | `DIV`（除法）                                      | `DIV AB`          | `A`÷`B`→`A`...`B`<br />`CY`总是被清零；<br />除数`B`=0时，`OV=1`，无意义；`B`≠0时，`OV`=0 |
   | `DA`（十进制调整，**D**ecimal **A**djust）         | `DA A`            |                                                              |

5. #### 逻辑运算（按位运算）

   |                                                              | 格式                                                         |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | `ANL` (**An**d **L**ogic)<br />`ORL`<br />`XRL`              | `ANL A,#data`<br />`ANL A,direct`<br />`ANL A,@Ri`<br />`ANL A,Rn`<br />`ANL direct,A`<br />`ANL direct,#data` |
   | `CLR`（累加器清零）                                          | `CLR A`                                                      |
   | `CPL`（累加器取反，**C**om**pl**ement）                      | `CPL A`                                                      |
   | `RL` (**R**otate **L**eft)<br />`RR`<br />`RLC` (**R**otate **L**eft through the **C**arry Flag)<br />`RRC` | `RL/RR/RLC/RRC A`（只能对`A`）                               |

   - 对标志位的影响：除了目的操作数为`ACC`的指令影响奇偶标志`P`外，一般不影响标志位
   - 与、或的应用：`ORL P1,#0FH ;将P1口的低4位置1`
   - 循环移位指令
     - 示意图：![image-20191015172002052](/Users/s.z.zheng/Library/Application Support/typora-user-images/image-20191015172002052.png)
     - `RLC`和`RRC`影响`P`和`CY`
     - 应用：`CY`清零后，执行`RLC A`可使`A`变为原来的2倍，执行`RRC`可使之变为原来的1/2

6. #### 控制转移

   |                                                              | 格式                                               | 效果                                                         |
   | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
   | `AJMP`（绝对转移，**A**bsolute **J**u**mp**）                | `AJMP addr11`                                      | 先执行`(PC)+2→PC`；<br />再用`addr11`的11位地址替换`PC`的低11位内容 |
   | `LJMP`（无条件长转移）                                       | `LJMP addr16`                                      | `addr16→PC`                                                  |
   | `SJMP`（短转移）                                             | `SJMP rel`                                         | `目的地址PC = (PC) + 02H + rel`；<br />`rel`为补码形式，为负时可实现向前转移 |
   | `JMP`（间接转移）                                            | `JMP @A+DPTR`                                      | `(A)+(DPTR)→PC`，即为目的地址                                |
   | `JZ`<br />`JNZ`（累加器判0转移，**J**ump if **N**ot **Z**ero） | `JZ rel`<br />`JNZ rel`                            | 先根据`A`的值判断是否跳转；<br />若跳转，`PC←(PC)+2+rel`；否则`PC←(PC)+2` |
| ‼️`CJNE`（数值比较不等转移，**C**ompare and **J**ump if **N**ot **E**qual） | `CJNE A/Rn/@Ri,#data,rel`<br />`CJNE A,direct,rel` | 1. 若`[操作数1] = [操作数2]`，则`PC←(PC)+3`，`CY←0`；<br />2.若`[操作数1] > [操作数2]`，则`PC←(PC)+3+rel`，`CY←0`；<br />3.若`[操作数1] < [操作数2]`，则`PC←(PC)+3+rel`，`CY←1`； |
   | `DJNZ`（减1条件转移，**D**ecrement and **J**ump if **N**ot **Z**ero） | `DJNZ Rn/direct,rel`                               | `[操作数1]`先减1；<br />若结果为0，则`PC←(PC)+2或3`（不转移）<br />若结果不为0，则`PC←(PC)+2或3+rel`（转移）<br />❗️若结合循环，则循环可以执行`[操作数1]` |

7. #### 子程序调用与返回

   |                                                              | 格式           | 效果                                                         |
   | ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ |
   | `ACALL`（绝对调用）                                          | `ACALL addr11` | `PC←(PC)+2`<br />`SP←(SP)+1,(SP)←(PC)的低8位`<br />`SP←(SP)+1,(SP)←(PC)的高8位`<br />`PC的低11位←addr11` |
   | `LCALL`（长调用）                                            | `LCALL addr16` | `PC←(PC)+3`<br />`SP←(SP)+1,(SP)←(PC)的低8位`<br />`SP←(SP)+1,(SP)←(PC)的高8位`<br />`PC的低11位←addr16` |
   | `RET`（子程序返回，**Ret**urn from subroutine）              | `RET`          | `PC的高8位←((SP)),SP←(SP)-1`<br />`PC的低8位←((SP)),SP←(SP)-1` |
   | `RETI`（中断服务子程序返回，**Ret**urn from **I**nterruption） | `RETI`         | 同上                                                         |

8. #### 空操作

   - `NOP` (No Operation)：`PC←(PC)+1`

### 位操作指令

1. #### 位传送

   - `MOV C,bit`或`MOV bit,C`
   - ⚠️必须通过`C`操作（若要在两个可寻址位之间传送，必须以`C`为桥梁）

2. #### 位复位、置位

   |                                                 | 格式                     |
   | ----------------------------------------------- | ------------------------ |
   | `SETB`（置1，**Set** **B**it）<br />→位操作独有 | `SETB C`<br />`SETB bit` |
   | `CLR`                                           | `CLR C`<br />`CLR bit`   |

3. #### 位逻辑运算

   |              | 格式                          |
   | ------------ | ----------------------------- |
   | `ANL`与`ORL` | `ANL C,bit`<br />`ANL C,/bit` |
   | `CPL`        | `CPL C`<br />`CPL bit`        |

4. #### 位控制转移

   |                                                              | 格式           | 效果                                                         |
   | ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ |
   | `JC` <br />（**J**ump if the **C**arry Flag is Set）         | `JC rel`<br /> | 若`(CY)`=1，跳转，`PC←(PC)+2+rel`<br />若`(CY)`≠1，不跳转，`PC←(PC)+2` |
   | `JNC`（**J**ump if **n**ot **C**arry）                       | `JNC rel`      | 若`(CY)`=0，跳转，`PC←(PC)+2+rel`<br />若`(CY)`≠0，不跳转，`PC←(PC)+2` |
   | `JB`                                                         | `JB bit,rel`   | 若`(bit)`=1，跳转，`PC←(PC)+3+rel`<br />若`(bit)`≠1，不跳转，`PC←(PC)+3` |
   | `JNB`                                                        | `JNB bit,rel`  | 若`(bit)`=0，跳转，`PC←(PC)+3+rel`<br />若`(bit)`≠0，不跳转，`PC←(PC)+3` |
   | `JBC`<br />（**J**ump if the **B**it is Set and **C**lear the Bit） | `JBC bit,rel`  | 若`(bit)`=1，跳转，`PC←(PC)+3+rel`同时`bit←0`<br />若`(bit)`≠1，不跳转，`PC←(PC)+3` |

### 伪指令

|                             | 功能                                                         | 举例                                          |
| --------------------------- | ------------------------------------------------------------ | --------------------------------------------- |
| `ORG`（**Or**i**g**in）     | 定位目的程序的起始地址                                       | `ORG 2000H`（必须为16位地址）                 |
| `END`                       | 汇编结束指令                                                 |                                               |
| `EQU`（**Equ**ate）         | 相当于C++中的宏                                              | `FLAG EQU 30H`                                |
| `BIT`                       | 相当于对于bit位的宏指令                                      | `OUTP BIT P1.1`                               |
| `DB`（**D**efine **B**yte） | 从指定单元开始定义（存储）若干个字节（8 bit）的数据或ASCII码字符，常用于定义数据常数表 | `DB 34H,0DEH,'K'`                             |
| `DW`（**D**efine **W**ord） | 从指定单元开始定义（存储）若干个字（16 bit）的数据或ASCII码字符 | `DW 34H,1234H,'K'`（不足2 Byte的，高字节置0） |
| `DS`                        | 在程序存储器中保留指定数目的单元                             |                                               |
| `DATA`                      |                                                              | `符号名 DATA 表达式`                          |

## 程序结构

### 顺序结构

- 例：求内部RAM的20H单元中变量的平方值，变量取值范围为0~5，结果存在21H单元

  ```ASM
  ORG 1000H
  MOV DPTR, #Table	;(DPTR) ← 2000H
  MOV A, 20H
  MOVC A, @A+DPTR	;若(A)=3，则将2003H单元中的内容送给A，即求3²=9
  MOV 21H, A
  SJMP $
  
  ORG 2000H
  Table: DB 0,1,4,9,16,25
  END
  ```

### 分支结构

- #### 单分支结构

  - 例：求`R2`中补码绝对值，正数不变，负数求补

    ```ASM
    START: MOV A, R2
    			 JNB ACC.7, NEXT	;通过A的最高位（符号位）判断A是否为正数：是0则跳转，不是0则求补
    			 CPL A	;负数变补
    			 INC A
    			 MOV R2, A
    NEXT:  SJMP NEXT	;结束
    ```

- #### 多重单分支结构

  - 多次使用条件转移指令，有多个条件判断，形成多个逐级分支

  - 例：$x$为补码表示的数，在40H单元，求符号函数$y={\rm sgn} (x)=\begin{cases}1,& x>0\\ 0, &x=0\\ -1, &x<0\end{cases}$，存于41H单元
  
    ```asm
  START: MOV A, 40H
    			 JZ STOR	;若x=0，则y=0=x
  			 JB ACC.7, NEGA	;x<0
    			 MOV A, #1	;x>0
    			 SJMP STOR
    NEGA:  MOV A, #0FFH	;-1的补码     
    STOR:  MOV 41H, A
    			 SJMP $
    			 END
    ```
  
- #### 多分支结构![B4D1A58D-07AB-4603-9656-EDF3CC59FAEE_1_201_a](/Users/s.z.zheng/Pictures/照片图库.photoslibrary/resources/renders/B/B4D1A58D-07AB-4603-9656-EDF3CC59FAEE_1_201_a.jpeg)

  - ##### 法一：转移表法

    - 用分支转移指令`JMP @A+DPTR`

      表里存放的是转移指令

      目的是要计算出表地址

    - 例：分支数≤255的情况

      ```ASM
           MOV A, n				;n为分支序号
           RL A						;分支序号值×2（因为AJMP为2字节指令）
           MOV DPTR, #TAB ;转移指令表首地址
           JMP @A+DPTR
      TAB: AJMP ADDR0
      		 AJMP ADDR1
      		 ...
      		 AJMP ADDR127
      ```

    - 例：分支个数>255的情况（设分支号为`R7 R6`）

      ```ASM
      START: MOV DPTR, #TAB		;指向表首地址
      
      		   MOV A, R7       	
      		   MOV B, #3
      		   MUL AB 	        ;分支号高字节×3（LJMP为3字节指令）；乘积不超过1字节
      		   ADD A, DPH
      		   MOV DPH, A
      		   
      		   MOV A, R6       	
      		   MOV B, #3        
      		   MUL AB           ;分支号低字节×3；B中为R6×3的溢出位（进位），A中为R6×3的低字节
      		   XCH A, B					;将进位存在A中
      		   ADD A, DPH     	
      		   MOV DPH, A				;进位加到DPH上
      		   XCH A, B 	      ;A←((R7R6)×3)低字节
      		   
      		   JMP @A+DPTR  	  ;实现多分支转移
      		   
      TAB:   LJMP ADDR0     	;转移表
      		   LJMP ADDR1
      			 ...
      		   LJMP ADDRn
      		   
      ADDR0: ...	       	    ;程序段0
      ADDR1: ...	       	    ;程序段1
      ```

  - ##### 法二：地址表法
  
    - 用指令`JMP @A+DPTR`
  
      ```assembly
      START: MOV DPTR, #TAB
             MOV A, R3						;R3为分支号
             RLC A								;分支号×2
             JNC LOOP							;判断×2后是否有进位，无进位（C=0）则转移
             INC DPH							;有进位DPH+1
      LOOP:  MOV R4, A
             MOVC A, @A+DPTR			;查表取值（表是按照ADDR0高位、ADDR0低位、ADDR1高位…的顺序存储的），先取高8位
             XCH A, R4						;R4暂存要跳转的地址的高8位
             INC A								;指向低8位
             MOVC A, @A+DPTR			;取要跳转地址的低8位
             MOV DPL, A
             MOV DPH, R4
             CLR A
             JMP @A+DPTR
      TAB:   DW ADDR0
             DW ADDR1
             ...
      ADDR0: ...
      ADDR1: ...
             ...
      ```
  
    - 用指令`RET`，通过堆栈弹出`PC`实现转移
  
      ```assembly
      START: MOV DPTR, #TAB 	;取表首地址
      			 MOV A, R3
      			 CLR C
      			 RLC A						;分支号×2
      			 JNC LOOP
      			 INC DPH
      LOOP:  MOV R4, A
             INC A						;低字节先入栈
             MOVC A, @A+DPTR	;取分支程序入口地址低8位
             PUSH ACC 				;地址低8位入栈保存
             MOV A, R4
             MOVC A, @A+DPTR 	;取分支程序入口地址高8位
             PUSH ACC 				;地址高8位入栈保存
             RET 							;分支地址→PC，转移
      TAB:   DW ADDR0 				;分支地址表
             DW ADDR1
             ...
      ADDR0: ...
      ADDR1: ...
      ```

### 循环结构

- 常用控制循环的方法：
  - 计数控制：`DJNZ Ri, LOOP`
  - 条件控制：`CJNE A, B, LOOP`：
    1. 若`[操作数1] = [操作数2]`，不跳转，`CY←0`
    2. 若`[操作数1] > [操作数2]`，跳转，`CY←0`
    3. 若`[操作数1] < [操作数2]`，跳转，`CY←1`
- 例6～例9见ppt

### 子程序

- 子程序入口用标号作为子程序名，即为子程序入口地址
- 用`RET`结束子程序并返回入口的位置

## 中断

### 概念

- 中断：CPU在正常运行程序时，由于CPU以外某一事件的发生，引起了CPU中断正在执行的程序，而转去为预先安排的该事件服务的程序中去执行。处理完成后，能够返回到断点处继续执行被中断的事情。这一过程就是中断。
- 中断源：引起程序中断的事件

### 中断源与中断向量

- 共有5个中断：外部中断0、外部中断1、定时器中断0、定时器中断1、串行中断

- 共有6个中断源：

  - 外部中断0：$\overline{{\rm INT0}}$，由P3.2提供
  - 外部中断1：$\overline{{\rm INT1}}$，由P3.3提供
  - 定时/计数器T0溢出中断TF0，由片内定时/计数器0提供
  - 定时/计数器T1溢出中断TF1，由片内定时/计数器1提供
  - 串行发送中断TI，由片内串行口提供
  - 串行接收中断RI，由片内串行口提供

- 共有5个中断入口（向量）：

  | 中断名称     | 中断向量（入口地址） |
  | ------------ | -------------------- |
  | 外部中断0    | 0003H                |
  | 定时器中断0  | 000BH                |
  | 外部中断0    | 0013H                |
  | 外部中断1    | 001BH                |
  | 串行发送中断 | 0023H                |
  | 串行接收中断 | 0023H                |

  - 每个中断源入口空间只有8个单元
  - 在这些单元中，往往存放跳转指令，使其跳到真正的中断服务程序

- 中断请求的产生

  - 外部中断：
    - 电平方式（低电平有效）：只要在中断请求引入端（$\overline{{\rm INT0}}$ 或 $\overline{{\rm INT1}}$）上采样到低电平信号，即为中断请求
    - （负跳）脉冲方式：在相邻两个机器周期所进行的两次采样中，若前一次为高，后一次为低，即为中断请求
  - 定时器中断：计数器溢出时，产生中断请求
  - 串行中断：每当串行口发送/接收完一帧串行数据时，即产生相应的中断请求

### 中断控制的相关寄存器

- #### 中断允许控制寄存器`IE`（Interrupt Enable）

  - 地址：`A8H`

  - 位定义与位地址：

    | 位地址 | `AFH` | `AEH` | `ADH` | `ACH` | `ABH` | `AAH` | `A9H` | `A8H` |
    | ------ | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
    | 位符号 | `EA`  | —     | —     | `ES`  | `ET1` | `EX1` | `ET0` | `EX0` |

  - 功能：

    - `EA`：中断允许总控制位
    - `EX0`和`EX1`：外部中断0和外部中断1的中断允许控制位
    - `ET0`和`ET1`：定时器中断0和定时器中断1的中断允许控制位
    - `ES`：串行中断允许控制位

  - 各位均为高有效，即为1时允许对应的中断，为0时禁止对应的中断

  - 如：要打开外部中断1（两种方法）：

    - `MOV IE, #84H`：将`EA`和`EX1`置1，其余置0，则对应1000 0100，即为84H
    - 分别执行`SETB EA`和`SETB EX1`

- #### 定时器控制寄存器`TCON`（Timer Control）

  - 地址：`88H`

  - 位定义与位地址：

    | 位地址 | `8FH` | `8EH` | `8DH` | `8CH` | `8BH` | `8AH` | `89H` | `88H` |
    | ------ | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
    | 位符号 | `TF1` |       | `TF0` |       | `IE1` | `IT1` | `IE0` | `IT0` |

  - 功能：

    - `TF0`和`TF1`：定时器`T0`、`T1`溢出标志位。由硬件置1
    - `IE0`和`IE1`：外部中断请求标志位。由硬件自动置位和清零
    - `IT0`和`IT1`：外部中断触发方式控制位。1为脉冲触发，0为电平触发

- #### 串行口控制寄存器`SCON`（Serial Control）

  - 地址：`98H`

  - 位定义与位地址：

    | 位地址 | `9FH` | `9EH` | `9DH` | `9CH` | `9BH` | `9AH` | `99H` | `98H` |
    | ------ | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
    | 位符号 |       |       |       |       |       |       | `TI`  | `RI`  |

  - 功能：

    - `TI`：串行发送中断请求标志位。当最后一个数据位发送完后，**`TI`**由硬件自动置位，向CPU发中断申请。进行中断服务程序时，`TI`要手动清零
    - `RI`：串行接受中断请求标志位。当接收到最后一个数据位后，`RI`由硬件自动置位，向CPU发中断申请。进行中断服务程序时，`RI`要手动清零

- #### 中断优先级控制寄存器`IP`（Interrupt Priority）

  - 地址：`B8H`

  - 位定义与位地址：

    | 位地址 | `BFH` | `BEH` | `BDH` | `BCH` | `BBH` | `BAH` | `B9H` | `B8H` |
    | ------ | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
    | 位符号 | —     | —     | —     | `PS`  | `PT1` | `PX1` | `PT0` | `PX0` |

  - 功能：从高到低，分别为串行中断、定时器中断1、外部中断1、定时器中断0、外部中断0的中断优先级设定位。置1为高优先级，置0为低优先级

### 中断优先级控制

- 只有高优先级中断可以中断低优先级的中断服务，从而实现中断嵌套（同优先级也不能嵌套）
- 同级中断源优先级顺序：![image-20191112233806221](/Users/s.z.zheng/Library/Application Support/typora-user-images/image-20191112233806221.png)
- 中断系统控制逻辑：![4196AF7E-EC92-4D62-8884-EA906F0666DA_1_105_c](/Users/s.z.zheng/Pictures/照片图库.photoslibrary/resources/derivatives/4/4196AF7E-EC92-4D62-8884-EA906F0666DA_1_105_c.jpeg)

### 中断响应

- #### 中断响应的基本条件（具体见ppt p26）

  - 有中断源发出中断申请
  - 中断总允许位`EA = 1`
  - 各个中断源相应的允许位置1，即`ES`、**`ET1`**、**`EX1`**、**`ET0`**、**`EX0`**

- #### 中断响应的过程

  - 将响应的优先级状态触发器置1
  - 由硬件清除相应的中断请求标志位：`TFx`、`IEx`。但串行中断标志位必须手动清除
  - 执行一条由硬件生成的长调用指令**`LCALL`**。其格式为**`LCALL addr16`**，这里的**`addr16`**就是程序存储器中相应中断区的入口地址。该指令将自动把断点地址（当前**`PC`**值）压入堆栈保护起来，然后将对应的中断入口地址装入**`PC`**，使程序转向该中断入口地址，去执行中断服务程序

- #### 中断服务程序

  - 现场保护和现场恢复：
    - 现场保护：位于中断处理程序首部，`PUSH direct`
    - 现场恢复：位于中断处理程序尾部，`POP direct`
  - 开中断和关中断
    - 在中断处理程序中，关中断可以禁止响应其他一切中断
    - 分别在现场保护和现场恢复前后，加上关中断和开中断，避免现场被破坏
  - 中断处理
  - 中断返回：
    - 中断服务程序的最后一条指令必须是中断返回指令`RETI`
    - 清除优先级状态；返回`PC`

